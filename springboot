 컴퓨터는 영어를 알아먹지 못한다
바이너리 코드로 번역
영어 코드 -> 컴파일러 -> 바이너리 코드
OS마다 알아먹을 수도 있고 못 알아 먹을수도 있다
JVM은 java이외에 다른부분에도사용가능

java virtual machine -> java class library(jre) -> java development kit

빌드 - 코드를 하나로 응축

테스트 과정

패키징 - 모든것을 하나로

gradle - grovvy, xml 대신 씀

http 헤더 바디
프로토콜 구분 도메인 구분 패스 구분 패스

API - 규칙

@RequestParam @RequestBody
int는 null을 표현할 수 없고 Integer는 null을 표현할 수 있다

@getMapping - @RequestParam
@PostMapping - @RequestBody

서버가 종료될때 램에 있는 정보들은 사라지게 된다

RDBMS DBMS

jpa orm object relational mapping 객체와 테이블을 짝짓는다

jdbc 런타임 jpa 컴파일 과정

jpa java persistence api

짝짓기의 규칙을 구현화하는것이 hibernate

@Entity 테이블과 객체를 같은것으로 인식

@Id primary key

@GeneratedValue primary key의 자동생성

public enum GenerationType

TABLE

SEQUENCE

IDENTITY

AUTO

char(a) a자릿수만입력가능
varchar(a)  a자릿수까지입력가능

application.yml 시스템의 중추

jdbc java database connector 연결

driver-class-name db접근시 사용할 프로그램

// 생성자를 사용하지 않은 경우
class Student {
	String name; // 학생 이름
	int age; // 학생 나이
	int number; // 학생 학번
}

public class StudentMain {

	public static void main(String[] args) {

		Student st = new Student();

		st.name = "홍길동";
		st.age = 20;
		st.number = 00000000;
	}

}

class Student {
	String name; // 학생 이름
	int age; // 학생 나이
	int number; // 학생 학번

	Student() {
	}

	Student(String name, int age, int number) {
		this.name = name;
		this.age = age;
		this.number = number;
	}

}

public class Test01 {

	public static void main(String[] args) {
		Student st1 = new Student(); // 생성자 호출 부분에 인자가 없고 클래스에 인자가 있는
										// 생성자가 하나 이상 존재하기 때문에 빈 생성자를
										// 만들어 줘야 합니다.
		Student st2 = new Student("홍길동", 20, 111111);
	}

}

jdbcTemplate, rowMapper, java Lambda

@Configuration 클래스
@Bean 메서드

@Service 직접 제작
@Repository 직접 제작

JDBC template

@Component 숨어있다

@AutoWired 매게변수에 bean을 연결
생성자
Setter

@Qulifier 가져오다
@Primary 2순위

@Entity 쿼리안쓴다

ORM SQL

@ManyToOne <-> @OneToMany(mapped by) <-> @OneToOne

연관관계
